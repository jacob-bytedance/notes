---
title: MyBatis with Spring Boot
---
# 1. Introduction

## 1.1. Overview of MyBatis

MyBatis is a data mapper framework that connects Java applications to relational databases. It enables java code to execute SQL statements, retrieve data, and manage database transactions.

## 1.2. Benefits of MyBatis

- **Fine-Grained Control:** Specify the desired SQL queries for precise and optimized database operations.
- **Flexibility:** Handle complex SQL queries or database operations.
- **Simplicity:** MyBatis simplifies data mapping
- **Integration with Spring:** Easy to integrate

## 1.3 Follow Along The Tutorial

You can follow along with this tutorial via the [MyBatis-SpringBoot repository on GitHub](https://github.com/jacob-bytedance/MyBatis-SpringBoot).

# 2. Setting Up the Development Environment

## 2.1. Prerequisites

Before we dive into the coding, ensure you have the following tools installed:

- **Java Development Kit (JDK)**
  
- **Maven**

- **Integrated Development Environment (IDE):** IntelliJ IDEA

## 2.2. Creating a New Spring Boot Project

1. **Use Spring Initializr:** [start.spring.io](https://start.spring.io/).
2. **Configure the Project:**
   - **Project:** Maven Project.
   - **Language:** Java.
   - **Spring Boot:** 3.3.3, the latest stable version.
   - **Group:** `org.jacobwu`.
   - **Artifact:** `mybatis-springboot`.
   - **Name:** `mybatis-springboot`.
   - **Description:** A demo project for MyBatis with Spring Boot.
   - **Packaging:** Jar.
   - **Java Version:** 17.
3. **Add Dependencies:**
   - **Spring Web**
   - **MyBatis Framework**
   - **H2 Database:** For an in-memory database
4. **Generate the Project:** Click the "Generate" button to download the project as a ZIP file. Extract the ZIP file and open it in your IDE.

# 3. MyBatis Configuration in Spring Boot

Spring Boot simplifies configuration by providing defaults based on the dependencies included in the project. Let’s set up the basic configuration in the `application.properties` file to get our project up and running.

1. **Open `application.properties`:** Located in `src/main/resources`.
2. **Add the following properties:**

```properties
spring.application.name=mybatis  
  
################################################################################################################################  
# Hibernate / JPA properties                                                                                                   #  
################################################################################################################################  
  
# Specifies the JDBC URL to connect to an H2 in-memory database named 'testdb'.  
# The 'mem' prefix indicates that the database is created in memory and will be lost when the application stops.  
spring.datasource.url=jdbc:h2:mem:db  
  
# Tells Hibernate how to handle database schema updates.  
# 'update' will automatically create and update the schema based on your entities, without dropping existing tables.  
# This is useful for development but should be used cautiously in production.  
spring.jpa.hibernate.ddl-auto=update  
  
# Enables logging of the SQL statements generated by Hibernate.  
# Useful for debugging and understanding what SQL queries are being executed.  
spring.jpa.show-sql=true  
  
# Enables the H2 web console, a tool that allows you to interact with the H2 database through a web interface.  
# This is useful during development but should be disabled in production.  
spring.h2.console.enabled=true  
  
# Specifies the URL path to access the H2 web console.  
# In this case, the console can be accessed at '/h2-console' in your web browser.  
spring.h2.console.path=/h2-console  
  
# Specifies the location of MyBatis XML mapper files within the classpath.  
# The 'classpath:' prefix indicates that the files are located in the resources directory.  
# 'mapper/*.xml' tells MyBatis to look for any XML files in the 'mapper' folder.  
mybatis.mapper-locations=classpath:mapper/*.xml
```

# 4. Creating Entity Object

## 4.1 Manual Creation

As an example, we will create a database of metrics. We start off with `MetricPO.java` located in `src/main/org/jacobwu/mybatis/entity/MetricPO.java`. The getters and setters are created via IntelliJ's generators for getters and setters.

```java
package org.jacobwu.mybatis.entity;  
  
import java.time.LocalDateTime;  
  
public class MetricPO {  
  
    private Long id;                     // The primary key  
    private String key;                  // A unique key for the metric  
    private String name;                 // The name of the metric  
    private String description;          // A description of the metric  
    private Double value;                // The current value of the metric  
    private LocalDateTime createdAt;     // Timestamp when the metric was created  
    private LocalDateTime updatedAt;     // Timestamp when the metric was last updated  
    private String status;               // The status of the metric (e.g., active, inactive)  
    private String category;             // The category of the metric  
    private String module;               // The module to which the metric belongs  
  
    public Long getId() {  
        return id;  
    }  
  
    public void setId(Long id) {  
        this.id = id;  
    }  
  
    public String getKey() {  
        return key;  
    }  
  
    public void setKey(String key) {  
        this.key = key;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public String getDescription() {  
        return description;  
    }  
  
    public void setDescription(String description) {  
        this.description = description;  
    }  
  
    public Double getValue() {  
        return value;  
    }  
  
    public void setValue(Double value) {  
        this.value = value;  
    }  
  
    public LocalDateTime getCreatedAt() {  
        return createdAt;  
    }  
  
    public void setCreatedAt(LocalDateTime createdAt) {  
        this.createdAt = createdAt;  
    }  
  
    public LocalDateTime getUpdatedAt() {  
        return updatedAt;  
    }  
  
    public void setUpdatedAt(LocalDateTime updatedAt) {  
        this.updatedAt = updatedAt;  
    }  
  
    public String getStatus() {  
        return status;  
    }  
  
    public void setStatus(String status) {  
        this.status = status;  
    }  
  
    public String getCategory() {  
        return category;  
    }  
  
    public void setCategory(String category) {  
        this.category = category;  
    }  
  
    public String getModule() {  
        return module;  
    }  
  
    public void setModule(String module) {  
        this.module = module;  
    }  
}
```

## 4.2 Automatic Creation

As an alternative to 4.1, you can describe the changes inside generatorConfig.xml and have MyBatis automatically create the file for you. An example is shown below.

```xml
<table tableName="metric" domainObjectName="MetricAccessPO"  
       enableSelectByPrimaryKey="true"  
       enableCountByExample="true"  
       enableUpdateByExample="true"  
       enableDeleteByExample="true"  
       enableSelectByExample="true"  
       selectByExampleQueryId="true">  
    <property name="needIdGenColumn" value="id"/>  
</table>
```

Then, run the command `mvn mybatis-generator:generate` inside the appropriate sub-directory (e.g. service) to generate the file.

# 5. Working with MyBatis Mappers

## 5.1 Creating Mapper Interfaces

The mapper interfaces are used to define the SQL operations that can be performed on the database. We create `MetricPOMapper.java` located at `src/main/java/org/jacobwu/mybatis/mapper/MetricPOMapper.java`

```java
package org.jacobwu.mybatis.mapper;  
  
import org.jacobwu.mybatis.entity.MetricPO;  
  
import java.util.List;  
  
public interface MetricPOMapper {  
    List<MetricPO> findAll();  
    MetricPO findById(Long id);  
    void insert(MetricPO metricPO);  
    void update(MetricPO metricPO);  
    void delete(Long id);  
}
```

## 5.2 Defining Mapper Operations

When it comes to SQL operations, we have two options: Either use annotations to describe the SQL queries, or use a dedicated XML mapper to specify the query operations. We illustrate both approaches, but the sample code uses the latter approach.

### 5.2.1 Adding SQL queries using Annotations

We add annotations to `MetricPOMapper.java` located at `src/main/java/org/jacobwu/mybatis/mapper/MetricPOMapper.java`

```java
package com.example.mybatis.mapper;

import com.example.mybatis.entity.MetricPO;
import org.apache.ibatis.annotations.*;

import java.util.List;

public interface MetricPOMapper {

    @Select("SELECT * FROM metrics WHERE id = #{id}")
    MetricPO findById(Long id);

    @Insert("INSERT INTO metrics (key, name, description, value, created_at, updated_at, status, category, module) VALUES (#{key}, #{name}, #{description}, #{value}, #{createdAt}, #{updatedAt}, #{status}, #{category}, #{module})")
    void insert(MetricPO metric);

    @Update("UPDATE metrics SET key=#{key}, name=#{name}, description=#{description}, value=#{value}, updated_at=#{updatedAt}, status=#{status}, category=#{category}, module=#{module} WHERE id=#{id}")
    void update(MetricPO metric);

    @Delete("DELETE FROM metrics WHERE id = #{id}")
    void delete(Long id);

    @Select("SELECT * FROM metrics")
    List<MetricPO> findAll();
}
```

### 5.2.2 Creating XML Mapper

We create an XML mapper file describing the query operations, `MetricPOMapper.xml` located at `src/main/resources/mapper/MetricPOMapper.xml`. Note that we enclose "key" and "value" in quotation marks since they are reserved keywords in SQL.

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper  
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
  
<mapper namespace="org.jacobwu.mybatis.mapper.MetricPOMapper">  
  
    <!-- Select all metrics -->  
    <select id="findAll" resultType="org.jacobwu.mybatis.entity.MetricPO">  
        SELECT * FROM metrics    </select>  
  
    <!-- Select a metric by ID -->  
    <select id="findById" parameterType="long" resultType="org.jacobwu.mybatis.entity.MetricPO">  
        SELECT * FROM metrics WHERE id = #{id}    </select>  
  
    <!-- Insert a new metric -->  
    <insert id="insert" parameterType="org.jacobwu.mybatis.entity.MetricPO">  
        INSERT INTO metrics ("key", name, description, "value", created_at, updated_at, status, category, module)        VALUES (#{key}, #{name}, #{description}, #{value}, #{createdAt}, #{updatedAt}, #{status}, #{category}, #{module})    </insert>  
  
    <!-- Update an existing metric -->  
    <update id="update" parameterType="org.jacobwu.mybatis.entity.MetricPO">  
        UPDATE metrics        SET "key"=#{key}, name=#{name}, description=#{description}, "value"=#{value}, updated_at=#{updatedAt},            status=#{status}, category=#{category}, module=#{module}        WHERE id=#{id}    </update>  
  
    <!-- Delete a metric by ID -->  
    <delete id="delete" parameterType="long">  
        DELETE FROM metrics WHERE id = #{id}    </delete>  
  
</mapper>
```

After defining the XML mapper, we need to inform Spring Boot so it knows where to find the mapper. We do so via an annotation to the MybatisApplication class in `src/main/java/org/jacobwu/mybatis/MybatisApplication.java`

```java
package org.jacobwu.mybatis;  
  
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
  
/**  
 * @author Jacob Wu
 */
@SpringBootApplication  
@MapperScan("org.jacobwu.mybatis.mapper")
public class MybatisApplication {  
  
    public static void main(String[] args) {  
       SpringApplication.run(MybatisApplication.class, args);  
    }  
  
}
```

# 6. SQL Table

Now that we have defined the database operations, we need to create the table inside the database. Optionally, we can populate the table with sample data.

## 6.1 Creating SQL Table

We define the SQL table schema using the file `src/main/resources/schema.sql`. Since the file is located in the `resources` folder, Spring Boot automatically creates the table at the start of the Spring Boot Application.

```sql
CREATE TABLE metrics (  
                         id BIGINT AUTO_INCREMENT PRIMARY KEY,  
                         "key" VARCHAR(255) NOT NULL,  
                         name VARCHAR(255) NOT NULL,  
                         description TEXT,  
                         "value" DOUBLE,  
                         created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  
                         updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  
                         status VARCHAR(50),  
                         category VARCHAR(100),  
                         module VARCHAR(100)  
);
```

## 6.2 Populating SQL Table with Sample Data (optional)

We add some sample metrics to the SQL Table using the file `src/main/resources/data.sql`

```sql
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('user_signup_rate', 'User Signup Rate', 'Rate of user signups per day', 75.5, 'ACTIVE', 'User Engagement', 'User Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('page_view_count', 'Page View Count', 'Total number of page views per day', 12450.0, 'ACTIVE', 'Site Traffic', 'Analytics Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('avg_session_duration', 'Average Session Duration', 'Average duration of user sessions in minutes', 5.8, 'ACTIVE', 'User Engagement', 'User Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('bounce_rate', 'Bounce Rate', 'Percentage of users who leave after viewing only one page', 45.2, 'ACTIVE', 'Site Performance', 'Analytics Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('conversion_rate', 'Conversion Rate', 'Percentage of users who complete a purchase or desired action', 2.9, 'ACTIVE', 'Sales', 'Sales Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('customer_satisfaction', 'Customer Satisfaction Score', 'Average satisfaction score from customer surveys', 88.3, 'ACTIVE', 'Customer Feedback', 'Customer Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('cart_abandonment_rate', 'Cart Abandonment Rate', 'Percentage of users who abandon their cart before checkout', 67.5, 'ACTIVE', 'Sales', 'Sales Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('new_vs_returning_users', 'New vs Returning Users', 'Ratio of new users to returning users', 3.2, 'ACTIVE', 'User Engagement', 'User Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('churn_rate', 'Churn Rate', 'Percentage of users who stop using the service over time', 4.8, 'ACTIVE', 'User Retention', 'User Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('email_open_rate', 'Email Open Rate', 'Percentage of marketing emails opened by recipients', 25.1, 'ACTIVE', 'Marketing', 'Marketing Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('customer_lifetime_value', 'Customer Lifetime Value', 'Estimated revenue from a customer over their lifetime', 1250.0, 'ACTIVE', 'Sales', 'Sales Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('net_promoter_score', 'Net Promoter Score', 'Measures customer loyalty and likelihood to recommend', 72, 'ACTIVE', 'Customer Feedback', 'Customer Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('server_uptime', 'Server Uptime', 'Percentage of time the server is operational and online', 99.9, 'ACTIVE', 'Infrastructure', 'IT Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('error_rate', 'Error Rate', 'Percentage of transactions that fail due to errors', 1.2, 'ACTIVE', 'Site Performance', 'Analytics Module');  
  
INSERT INTO metrics ("key", name, description, "value", status, category, module)  
VALUES ('mobile_traffic_ratio', 'Mobile Traffic Ratio', 'Percentage of total traffic from mobile devices', 58.7, 'ACTIVE', 'Site Traffic', 'Analytics Module');
```

### 6.3 Interacting with the SQL Table

You can log in to the interactive H2 console via http://localhost:8080/h2-console/ with JDBC URL `jdbc:h2:mem:db` and username `sa` (leave password field blank). This was configured section 3 using `application.properties` and the username and password were set to default values (but can be changed by specifying the desired username and/or password in `application.properties).

After you log in, you can run SQL queries such as `SELECT * FROM metrics` to view all metrics.

# 7. Service Layer Integration

## 7.1. Creating the Service Class

The service layer in a Spring Boot application encapsulates the business logic. It typically interacts with the data access layer (in this case, MyBatis mappers) to perform operations.

We define the service in `src/main/java/org/jacobwu/mybatis/service/MetricService.java`

```java
package org.jacobwu.mybatis.service;  
  
import org.jacobwu.mybatis.entity.MetricPO;  
import org.jacobwu.mybatis.mapper.MetricPOMapper;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
  
@Service  
public class MetricService {  
  
    @Autowired  
    private MetricPOMapper metricPOMapper;  
  
    public List<MetricPO> getAllMetrics() {  
        return metricPOMapper.findAll();  
    }  
  
    public MetricPO getMetricById(Long id) {  
        return metricPOMapper.findById(id);  
    }  
  
    public void insertMetric(MetricPO metricPO) {  
        metricPOMapper.insert(metricPO);  
    }  
  
    public void updateMetric(MetricPO metricPO) {  
        metricPOMapper.update(metricPO);  
    }  
  
    public void deleteMetric(Long id) {  
        metricPOMapper.delete(id);  
    }  
}
```

# 8 Web Controller

## 8.1 Implementing Web Controller

The controller layer handles incoming HTTP requests and delegates them to the service layer. We use annotations like @RestController, @GetMapping, @PostMapping, @PutMapping, and @DeleteMapping to define your RESTful endpoints.

We implement the web controller in `src/main/java/org/jacobwu/mybatis/controller/MetricController.java`

```java
package org.jacobwu.mybatis.controller;  
  
import org.jacobwu.mybatis.entity.MetricPO;  
import org.jacobwu.mybatis.service.MetricService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.*;  
  
import java.util.List;  
  
@RestController  
@RequestMapping("/metrics")  
public class MetricController {  
  
    @Autowired  
    private MetricService metricService;  
  
    @GetMapping  
    public List<MetricPO> getAllMetrics() {  
        return metricService.getAllMetrics();  
    }  
  
    @GetMapping("/{id}")  
    public MetricPO getMetricById(@PathVariable Long id) {  
        return metricService.getMetricById(id);  
    }  
  
    @PostMapping  
    public void insertMetric(@RequestBody MetricPO metric) {  
        metricService.insertMetric(metric);  
    }  
  
    @PutMapping("/{id}")  
    public void updateMetric(@PathVariable Long id, @RequestBody MetricPO metric) {  
        metric.setId(id);  
        metricService.updateMetric(metric);  
    }  
  
    @DeleteMapping("/{id}")  
    public void deleteMetric(@PathVariable Long id) {  
        metricService.deleteMetric(id);  
    }  
  
}
```

## 8.2 Testing the Web Controller

You can test the web controller by sending these http requests using the Terminal

### 8.2.1 Get all metrics
```bash
curl -X GET http://localhost:8080/metrics
```

### 8.2.2 Insert metric
```bash
curl -X POST http://localhost:8080/metrics \
     -H "Content-Type: application/json" \
     -d '{
           "key": "metric-key-001",
           "name": "User Engagement Metric",
           "description": "Measures user engagement across various platforms.",
           "value": 85.0,
           "status": "ACTIVE",
           "category": "ENGAGEMENT",
           "module": "ANALYTICS"
         }'
```

### 8.2.3 Update metric
```bash
curl -X PUT http://localhost:8080/metrics/1 \
     -H "Content-Type: application/json" \
     -d '{
           "key": "metric-key-001",
           "name": "Updated User Engagement Metric",
           "description": "Updated description for the user engagement metric.",
           "value": 90.0,
           "status": "ACTIVE",
           "category": "ENGAGEMENT",
           "module": "ANALYTICS"
         }'
```

### 8.2.4 Delete metric
```bash
curl -X DELETE http://localhost:8080/metrics/1
```